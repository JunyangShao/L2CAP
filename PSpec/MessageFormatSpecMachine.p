event eParsetFix : tFix;
event eParsetVar : tVar;
event eParsetHdr : tHdr;
event eParsetPara : tPara;
event eParsetPlist : tPlist;
event eParsetMsg : tMsg;

event eComposetFix : tFix;
event eComposetVar : tVar;
event eComposetHdr : tHdr;
event eComposetPara : tPara;
event eComposetPlist : tPlist;
event eComposetMsg : tMsg;

spec MessageFormatSpecMachine observes
eParsetFix, eParsetVar, eParsetHdr, eParsetPara, eParsetPlist, eParsetMsg,
eComposetFix, eComposetVar, eComposetHdr, eComposetPara, eComposetPlist, eComposetMsg {

    start state Init {
        entry{
            goto Observe;
        }
        ignore eParsetFix, eParsetVar, eParsetHdr, eParsetPara, eParsetPlist, eParsetMsg,
                eComposetFix, eComposetVar, eComposetHdr, eComposetPara, eComposetPlist, eComposetMsg;
    }
    state Observe{
    // Noted that only tFix and tVar here is associated with a value buffer and we only check them.
    // All higher-level types will not be expressed as a buffer.
    // This is because P does not support sub-type, so we cannot have ProFactory style model-checking here:
    //
    //      - ProFactory style model-checking combines symbolic fields(aka. concrete types, let's note as S) and concrete fields(let's note it as C)
    //      And after the code generation, only C will be passed on communication channels(actually C is just a buffer), S are only used for model-checking.
    //      All the S are evaluated from an abstract types in Haskell. Hence its very simple to define different S.
    //
    //      - However in P we don't support such kind of operation X=(abstract types)-[evaluated]->(concrete types).
    //          - Imagine, if we want to implement X in P(only using built-in types) without even a "const int" type, we will need to hard-coded everything in the code,
    //          making it hard to maintain.
    //          - But actually if the code is generated by program then it's not a problem, but here we are still implementing it manually, hence we want some workaround.
    //
    //      - As workaround we directly use concrete types in P, and reinterpret the operation X to
    //      Y=(default types)-[initialize value fields]->(evaluated types). And we will need to transmit the value fields together in the
    //      communication channels(in the P part).
    //      For now this workaround is semantically equal to ProFactory **IF**
    //          1. We define some foreign parse/compose function that is guaranteed to be correct and can translate Kernel Style buffers in communications to the types
    //              we defined above. And if there the buffer has invalid size the functions should still be able to translate it but will mark some tFix/tVar fields to be
    //              invalid that can be detected in the Spec Machine.
    //      Currently 1. haven't been implemented, there will be one parse/compose functions for each type we defined in Types.p respectively.
    //      Intuitively 1. should have a feasible implementation that won't take much effort.
    //
    //      - A Future better workaround:
    //      write more foreign functions and foreign types to relief the need to transmit value fields together in the communication channels(in the P part).
        on eParsetFix do (value: tFix){
            checktFix(value);
        }
        on eParsetVar do (value: tVar){
            checktVar(value);
        }
        on eParsetHdr do (value: tHdr){
            checktHdr(value);
        }
        on eParsetPara do (value: tPara){
            checktPara(value);
        }
        on eParsetPlist do (value: tPlist){
            checktPlist(value);
        }
        on eParsetMsg do (value: tMsg){
            checktMsg(value);
        }

        // for now the compose is identical to parse.
        on eComposetFix do (value: tFix){
            checktFix(value);
        }
        on eComposetVar do (value: tVar){
            checktVar(value);
        }
        on eComposetHdr do (value: tHdr){
            checktHdr(value);
        }
        on eComposetPara do (value: tPara){
            checktPara(value);
        }
        on eComposetPlist do (value: tPlist){
            checktPlist(value);
        }
        on eComposetMsg do (value: tMsg){
            checktMsg(value);
        }
    }

    fun checktFix (value: tFix) {
        var val : int;
        print "in Fix";
        val = readBuffer2(value.value);
        print format ("val={0}, value.nSize={1}, sizeof(value.value)={2} value.nHigh={3}, value.nLow={4}",
                    val, value.nSize, sizeof(value.value), value.nHigh, value.nLow);
        assert sizeof(value.value) == value.nSize;
        if(value.nSize != 0){
           assert val <= value.nHigh && val>= value.nLow;
        }
        print "out Fix";
        return;
    }

    fun checktVar (value: tVar) {
        var val : int;
        print "in Var";
        val = sizeof(value.value);
        assert val <= value.nHigh && val >= value.nLow;
        print "out Var";
        return;
    }

    fun checktHdr (value: tHdr) {
        var count : int;
        print "in Hdr";
        count = 0;
        checktFix(value.fLen);
        while(count < sizeof(value.f)){
            checktFix(value.f[count]);
            count = count + 1;
        }
        print "out Hdr";
        return;
    }

    fun checktPara (value: tPara) {
        var fval : int;
        print "in Para";
        checktFix(value.fKey);
        fval = readBuffer2(value.fKey.value);
        assert value.nKey == fval;
        checktFix(value.fVal);
        print "out Para";
        return;
    }

    fun checktPlist (value: tPlist) {
        var count : int;
        print "in Plist";
        count = 0;
        assert sizeof(value.pP) == value.nSize;
        while(count < value.nSize){
            checktPara(value.pP[count]);
            count = count + 1;
        }
        print "out Plist";
        return;
    }

    fun checktMsg (value: tMsg) {
         var count : int;
         var tmpmsg : tMsg;
         var flag : bool;
         var tmpvar : int;
         var tmpcMsub : tcMsub;
         count = 0;
         assert value.chosen>=0 && value.chosen <=5;
         if(value.chosen == 0){
             print "in 0";
             checktVar(value.v);
             print "out 0";
         }
         else if(value.chosen == 1){
             print "in 1";
             checktPara(value.p);
             print "out 1";
         }
         else if(value.chosen == 2){
             print "in 2";
             count = 0;
             while(count < sizeof(value.fp)){
                 checktFix(value.fp[count]);
                 count = count + 1;
             }
             print "out 2";
         }
         else if(value.chosen == 3){
             print "in 3";
             checktPlist(value.l);
             print "out 3";
         }
         else if(value.chosen == 4){
             print "in 4";
             checktHdr(value.hmsub.h);
             tmpmsg = value.hmsub.msub as tMsg;
             checktMsg(tmpmsg);
             print "out 4";
         }
         else if(value.chosen == 5){
             print "in 5";
             checktHdr(value.hcmsub.h);
             assert sizeof(value.hcmsub.h.f) >= 1;
             tmpvar = readBuffer2(value.hcmsub.h.f[0].value); // chosen sub-msg index
             count = 0;
             while(count < sizeof(value.hcmsub.msub)){
                 tmpcMsub = value.hcmsub.msub[count];
                 tmpmsg = tmpcMsub.msub as tMsg;
                 checktMsg(tmpmsg);
                 if(tmpcMsub.nType == tmpvar){
                     flag = true;
                 }
                 count = count + 1;
             }
             assert flag == true;
             print "out 5";
         }
         return;
    }
    fun readBuffer2 (buf : seq[int]) : int {
        var bufsize : int;
        var counter : int;
        var ret : int;

        bufsize = sizeof(buf);
        counter = 0;
        ret = 0;
        while (counter < bufsize){
            ret = ret * 256;
            ret = ret + buf[counter];
            counter = counter + 1;
        }
        return ret;
    }
}

