event eParsetFix : tFix;
event eParsetVar : tVar;
event eParsetHdr : tHdr;
event eParsetPara : tPara;
event eParsetPlist : tPlist;
event eParsetMsg : tMsg;

event eComposetFix : tFix;
event eComposetVar : tVar;
event eComposetHdr : tHdr;
event eComposetPara : tPara;
event eComposetPlist : tPlist;
event eComposetMsg : tMsg;

spec L2CAPFormatIsCorrect observes
eParsetFix, eParsetVar, eParsetHdr, eParsetPara, eParsetPlist, eParsetMsg,
eComposetFix, eComposetVar, eComposetHdr, eComposetPara, eComposetPlist, eComposetMsg {

    start state Init {
        entry{
            goto Observe;
        }
        ignore eParsetFix, eParsetVar, eParsetHdr, eParsetPara, eParsetPlist, eParsetMsg,
                eComposetFix, eComposetVar, eComposetHdr, eComposetPara, eComposetPlist, eComposetMsg;
    }
    state Observe{
    // Noted that only tFix and tVar here is associated with a value buffer and we only check them.
    // All higher-level types will not be expressed as a buffer.
    // This is because P does not support sub-type, so we cannot have ProFactory style model-checking here:
    //
    //      - ProFactory style model-checking combines symbolic fields(aka. concrete types, let's note as S) and concrete fields(let's note it as C)
    //      And after the code generation, only C will be passed on communication channels(actually C is just a buffer), S are only used for model-checking.
    //      All the S are evaluated from an abstract types in Haskell. Hence its very simple to define different S.
    //
    //      - However in P we don't support such kind of operation X=(abstract types)-[evaluated]->(concrete types).
    //          - Imagine, if we want to implement X in P(only using built-in types) without even a "const int" type, we will need to hard-coded everything in the code,
    //          making it hard to maintain.
    //          - But actually if the code is generated by program then it's not a problem, but here we are still implementing it manually, hence we want some workaround.
    //
    //      - As workaround we directly use concrete types in P, and reinterpret the operation X to
    //      Y=(default types)-[initialize value fields]->(evaluated types). And we will need to transmit the value fields together in the
    //      communication channels(in the P part).
    //      For now this workaround is semantically equal to ProFactory **IF**
    //          1. We define some foreign parse/compose function that is guaranteed to be correct and can translate Kernel Style buffers in communications to the types
    //              we defined above. And if there the buffer has invalid size the functions should still be able to translate it but will mark some tFix/tVar fields to be
    //              invalid that can be detected in the Spec Machine.
    //      Currently 1. haven't been implemented, there will be one parse/compose functions for each type we defined in Types.p respectively.
    //      Intuitively 1. should have a feasible implementation that won't take much effort.
    //
    //      - A Future better workaround:
    //      write more foreign functions and foreign types to relief the need to transmit value fields together in the communication channels(in the P part).
        on eParsetFix do (value: tFix){
            var val : int;
            val = readBuffer(value.value);
            assert sizeof(value.value) == value.nSize;
            assert val <= value.nHigh && val>= value.nLow;
            return;
        }
        on eParsetVar do (value: tVar){
            var val : int;
            val = sizeof(value.value);
            assert val <= nHigh && val >= nLow;
            return;
        }
        on eParsetHdr do (value: tHdr){
            var count : int;
            count = 0;
            announce eParsetFix, value.fLen;
            while(count < sizeof(value.f)){
                announce eParsetFix, value.f[count];
                count = count + 1;
            }
            return;
        }
        on eParsetPara do (value: tPara){
            var fval : int;
            announce eParsetFix, value.fKey;
            fval = readBuffer(value.fKey);
            assert value.nKey == fval;
            announce eParsetFix, value.fVal;
            return;
        }
        on eParsetPlist do (value: tPlist){
            var count : int;
            count = 0;
            while(count < value.nSize){
                announce eParsetPara, value.pP[count];
                count = count + 1;
            }
            return;
        }
        on eParsetMsg do (value: tMsg){
            var count : int;
            var tmpmsg : tMsg;
            var flag : bool;
            var tmpvar : int;
            var tmpcMsub : tcMsub;
            count = 0;
            assert value.chosen>=0 && value.chosen <=5;
            if(value.chosen == 0){
                announce eParsetVar, value.v;
            }
            else if(value.chosen == 1){
                announce eParsetPara, value.p;
            }
            else if(value.chosen == 2){
                count = 0;
                while(count < sizeof(value.fp)){
                    announce eParsetFix, value.fp[count];
                    count = count + 1;
                }
            }
            else if(value.chosen == 3){
                announce eParsetPlist, value.l;
            }
            else if(value.chosen == 4){
                announce eParsetHdr, value.hmsub.h;
                tmpmsg = value.hmsub.msub as tMsg;
                announce eParsetMsg, tmpmsg;
            }
            else if(value.chosen == 5){
                announce eParsetHdr, value.hcmsub.h;
                assert sizeof(value.hcmsub.h.f) >= 1;
                tmpvar = readBuffer(value.hcmsub.h.f[0]); // chosen sub-msg index
                count = 0;
                while(count < sizeof(value.hcmsub.msub)){
                    tmpcMsub = value.hcmsub.msub[count];
                    tmpmsg = tmpcMsub.msub as tMsg;
                    announce eParsetMsg, tmpmsg;
                    if(tmpcMsub.nType==tmpvar){
                        flag = true;
                    }
                    count = count + 1;
                }
                assert flag == true;
            }
            return;
        }

        // for now the compose is identical to parse.
        on eComposetFix do (value: tFix){
            var val : int;
            return;
        }
        on eComposetVar do (value: tVar){
            var val : int;
            return;
        }
        on eComposetHdr do (value: tHdr){
            var val : int;
            return;
        }
        on eComposetPara do (value: tPara){
            var val : int;
            return;
        }
        on eComposetPlist do (value: tPlist){
            var val : int;
            return;
        }
        on eComposetMsg do (value: tMsg){
            var val : int;
            return;
        }
    }
}
